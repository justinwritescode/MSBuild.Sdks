// 
// CreateUsingsProject.cs
// 
//   Created: 2022-11-12-08:52:03
//   Modified: 2022-11-12-03:59:07
// 
//   Author: Justin Chase <justin@justinwritescode.com>
//   
//   Copyright © 2022 Justin Chase, All Rights Reserved
//      License: MIT (https://opensource.org/licenses/MIT)
// 

using System.Text;
using System.Xml;
namespace MSBuild.UsingsSdk;

using System.Xml.Linq;
using Microsoft.Build.Execution;
using MSBC = Microsoft.Build.Construction;
using MSBEx = Microsoft.Build.Execution;

public class CreateUsingsProject : MSBTask
{
    [Required]
    public string InputFile { get; set; } = string.Empty;
    [Required]
	public string Version { get; set; } = string.Empty;
    [Required]
    public string OutputFile { get; set; } = string.Empty;

    public virtual IEnumerable<ProjectInstance?> Load(string? path)
    {
		if(path is null) return new[] { null as ProjectInstance };
        var project = new ProjectInstance(path);
        return new [] { project }.Concat(project.EvaluatedItemElements.Where(element => element.ItemType == "UsingsImport").SelectMany(x => Load(x.Metadata.FirstOrDefault(md => md.Name == "Include")?.Value)))
		.Where(x => x is not null);
    }

    public override bool Execute()
    {
        var allProjects = Load(InputFile);
		var markdownReadme = new StringBuilder();
		markdownReadme.AppendFormat("---{0}title: {1}.Usings{0}version: {2}{0}---{0}{0}", Environment.NewLine, Path.GetFileNameWithoutExtension(InputFile), Version);
		markdownReadme.AppendLine($"## {Path.GetFileNameWithoutExtension(InputFile)}.Usings");
		markdownReadme.AppendLine();
		markdownReadme.AppendLine("This project contains a set of `using` statements and package and product imports for reuse in other projects.");

        Console.WriteLine("Found " + allProjects.Count() + " imported projects to process");

        var usings = allProjects.SelectMany(project => project.EvaluatedItemElements.Where(element => element.ItemType == "Using").OrderBy(x => x.Metadata.FirstOrDefault(md => md.Name == "Include")?.Value)).ToArray();
        var projectReferences = allProjects.SelectMany(project => project.EvaluatedItemElements.Where(element => element.ItemType == "ProjectReference").OrderBy(x => x.Metadata.FirstOrDefault(md => md.Name == "Include")?.Value)).ToArray();
        var packageReferences = allProjects.SelectMany(project => project.EvaluatedItemElements.Where(element => element.ItemType == "PackageReference").OrderBy(x => x.Metadata.FirstOrDefault(md => md.Name == "Include")?.Value)).ToArray();
        var properties = allProjects.SelectMany(project => project.Properties.OrderBy(x => x.Name)).ToArray();

        var usingsFile = new XDocument(
            new XElement("Project",
                new XComment("<auto-generated />"),
                new XComment("This code was generated by a tool.  Do not modify it."),
				new XComment("Usings: " + usings.Length),
				new XComment("Usings: " + usings.Length),
				new XComment("properties: " + properties.Length),
                new XComment("⬇️ Properties ⬇️"),
                new XElement("PropertyGroup",
                    properties.Select(FormatProperty).Concat(new[] { new XElement("Description", $"Contains `usings` for {Path.GetFileNameWithoutExtension(InputFile)}") }),
                new XElement("ItemGroup",
                    new XAttribute("Label", "Usings"),
                    new XComment("⬇️ Usings ⬇️"),
                    usings.Select(FormatUsing)),
                new XElement("ItemGroup",
                    new XAttribute("Label", "Package References"),
                    new XComment("⬇️ Package References ⬇️"),
                    packageReferences.Select(FormatPackageReference)),
                new XElement("ItemGroup",
                    new XAttribute("Label", "Project References"),
                    new XComment("⬇️ Project References ⬇️"),
                    projectReferences.Select(FormatProjectReference)))));
        Log.LogMessage("Properties: " + usingsFile.Descendants("PropertyGroup").Count());
        Log.LogMessage("packageReferences: " + usingsFile.Descendants("PackageReference").Count());

		markdownReadme.AppendLine("### Usings");
		markdownReadme.AppendLine();
		markdownReadme.AppendLine(usings.Select(x => $"{x.Metadata.FirstOrDefault(md => md.Name == "Include")?.Value}{FormatIsStatic(x)}{FormatAlias(x)}").Aggregate((a, b) => $"{a}{Environment.NewLine}{b}"));


        using (var outFile = File.CreateText(OutputFile))
        {
            usingsFile.Save(outFile);
        }
        // File.CreateText(OutputFile).Write(usingsFile.ToString());
        Log.LogMessage(usingsFile.ToString());
        Log.LogMessage("Wrote file: " + OutputFile);

        // var projectFile = new XDocument();
        // projectFile.Add(new XElement("Project",
        //     new XComment("<auto-generated />"),
        //     new XComment("This code was generated by a tool.  Do not modify it."),
        //     new XElement("PropertyGroup",
        //         new XElement("TargetFramework", "netstandard1.0", new XAttribute("Condition", "'$(TargetFramework)' == ''")),
        //         new XElement("LangVersion", "latest", new XAttribute("Condition", "'$(LangVersion)' == ''"),
        //         new XElement("EnableCentralPackageVersions", "false"),
        //         new XElement("GeneratePackageOnBuild", "true"),
        //         new XElement("IsNuGetized", "true"))),
        //     new XElement("ItemGroup",
        //         new XAttribute("Label", "Usings File"),
        //         new XElement("PackageFile", new XAttribute("Include", OutputFile), new XAttribute("PackagePath", "build/" + Path.GetFileName(OutputFile))),
        //     new XElement("ItemGroup",
        //         new XAttribute("Label", "Package References"),
        //         new XElement("PackageReference", new XAttribute("Include", "NuGetizer"), new XAttribute("Version", "0.9.0"))))));
        // projectFile.WriteTo(new System.Xml.XmlTextWriter(File.CreateText(Path.ChangeExtension(OutputFile, ".nuproj"))));

        return true;
    }

	private static XElement FormatUsing(MSBC.ProjectItemElement @using)
	{
		var include = @using.Metadata.FirstOrDefault(md => md.Name == "Include")?.Value;
		var alias = @using.Metadata.FirstOrDefault(md => md.Name == "Alias")?.Value;
		var isStatic = @using.Metadata.FirstOrDefault(md => md.Name == "Static")?.Value;
		return new XElement("Using", new XAttribute("Include", include), alias is not null ? new XAttribute("Alias", alias) : null, isStatic is not null ? new XAttribute("Static", isStatic) : null);
	}

	private static XElement FormatPackageReference(MSBC.ProjectItemElement packageReference)
	{
		var metadata = packageReference.Metadata.Select(x => new XAttribute(x.Name, x.Value)).ToArray();
		return new XElement("PackageReference", metadata);
	}


	private static XElement FormatProjectReference(MSBC.ProjectItemElement packageReference)
	{
		var metadata = packageReference.Metadata.Select(x => new XAttribute(x.Name, x.Value)).ToArray();
		return new XElement("ProjectReference", metadata);
	}

	private static XElement FormatProperty(MSBEx.ProjectPropertyInstance property)
	{
		return new XElement(property.Name, property.EvaluatedValue);
	}

	private string FormatIsStatic(MSBC.ProjectItemElement x)
	{
		if (x.Metadata.FirstOrDefault(md => md.Name == "Static")?.Value == "true")
		{
			return " *(static)*";
		}
		return string.Empty;
	}

	private string FormatAlias(MSBC.ProjectItemElement x)
	{
		var alias = x.Metadata.FirstOrDefault(md => md.Name == "Alias")?.Value;
		if (string.IsNullOrWhiteSpace(alias))
			return string.Empty;
		return $" (Alias: *{alias}*)";
	}
}
